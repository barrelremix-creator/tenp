<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>テンパズル</title>
    <style>
        /* ページ全体のスタイル */
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Helvetica Neue", "Segoe UI", "Hiragino Kaku Gothic ProN", "Hiragino Sans", "Arial", "Meiryo", sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background-color: #f0f0f0;
            -webkit-user-select: none; /* テキスト選択を無効化 */
            user-select: none;
            touch-action: manipulation; /* ダブルタップ時のズームを無効化 */
        }
        
        /* ゲームコンテナ */
        #game-container {
            position: relative;
            width: 90%;
            max-width: 450px;
            aspect-ratio: 1 / 1;
            background-color: #fff;
            border: 2px solid #333;
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }

        /* 頂点の共通スタイル */
        .vertex {
            position: absolute;
            background-color: #4a90e2;
            color: white;
            font-weight: bold;
            display: flex;
            justify-content: center;
            align-items: center;
            border-radius: 50%;
            cursor: pointer;
            transition: transform 0.2s, background-color 0.2s;
            box-sizing: border-box;
            padding: 5px;
            line-height: 1.1;
            text-align: center;
        }
        
        .vertex.hidden { opacity: 0; pointer-events: none; }
        .vertex.selected { background-color: #d9534f; border: 4px solid #d43f3a; }
        .vertex.selected-subtract { background-color: #007bff; border: 4px solid #0056b3; }
        .vertex.selected-divide { background-color: #28a745; border: 4px solid #1e7e34; }
        .vertex.in-drag-chain { background-color: #5cb85c; border: 4px solid #4cae4c; transform: scale(1.1); }
        
        /* ボタンコンテナ */
        #button-container {
            position: absolute;
            top: -55px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            width: 100%;
            justify-content: center;
        }
        #reset-button, #next-puzzle-button {
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            color: white;
            border: none;
            border-radius: 5px;
            flex-shrink: 0;
        }
        #reset-button { background-color: #f0ad4e; }
        #next-puzzle-button { background-color: #337ab7; }
        
        /* メッセージエリア */
        #message-area {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%); font-size: 48px;
            color: #4CAF50; font-weight: bold; display: none; text-align: center;
        }
    </style>
</head>
<body>

<div id="game-container">
    <div id="button-container">
        <button id="reset-button">リセット</button>
        <button id="next-puzzle-button">次の問題</button>
    </div>
    <div id="v0" class="vertex" data-index="0"></div>
    <div id="v1" class="vertex" data-index="1"></div>
    <div id="v2" class="vertex" data-index="2"></div>
    <div id="v3" class="vertex" data-index="3"></div>
    <div id="message-area"></div>
</div>

<script>
    // --- レイアウト設定 ---
    const LAYOUT_CONFIG = {
        VERTEX_SIZE_VW: 20,   // 頂点のサイズ (ビューポート幅に対する%)
        VERTEX_MARGIN_VW: 5,  // 外枠からの間隔 (ビューポート幅に対する%)
        FONT_SIZE_RATIO: 0.4, // 頂点サイズに対するフォントサイズの割合
    };

    // --- 分数クラス ---
    class Fraction {
        constructor(n, d = 1) { this.n = n; this.d = d; this.simplify(); }
        _gcd(a, b) { return b === 0 ? a : this._gcd(b, a % b); }
        simplify() {
            const c = this._gcd(Math.abs(this.n), Math.abs(this.d));
            this.n /= c; this.d /= c;
            if (this.d < 0) { this.d *= -1; this.n *= -1; }
        }
        toString() { return `${this.n}/${this.d}`; }
        isInteger() { return this.d === 1; }
        static getResult(f) { return f.isInteger() ? f.n : f; }
    }

    // --- 計算ロジック ---
    function performOperation(op, v1, v2) {
        const f1 = (v1 instanceof Fraction) ? v1 : new Fraction(v1);
        const f2 = (v2 instanceof Fraction) ? v2 : new Fraction(v2);
        let r;
        switch (op) {
            case '+': r = new Fraction(f1.n * f2.d + f2.n * f1.d, f1.d * f2.d); break;
            case '-': r = new Fraction(f1.n * f2.d - f2.n * f1.d, f1.d * f2.d); break;
            case '*': r = new Fraction(f1.n * f2.n, f1.d * f2.d); break;
            case '/':
                if (f2.n === 0) return null;
                r = new Fraction(f1.n * f2.d, f1.d * f2.n); break;
        }
        return Fraction.getResult(r);
    }

    // --- ゲームデータと状態変数 ---
    let solvablePuzzles = [];
    let currentPuzzleIndex = 0;
    let initialNumbers = [], currentNumbers = [];
    let operationState = { type: null, sourceIndex: null };
    let isSumDragging = false, dragChain = [];
    let interactionState = { startX: 0, startY: 0, startTime: 0, pressTimer: null };

    // --- DOM要素 ---
    const gameContainer = document.getElementById('game-container');
    const vertices = Array.from(document.querySelectorAll('.vertex'));
    const resetButton = document.getElementById('reset-button');
    const nextPuzzleButton = document.getElementById('next-puzzle-button');
    const messageArea = document.getElementById('message-area');

    // --- 初期化・更新関数 ---
    function applyLayout() {
        const containerSize = gameContainer.offsetWidth;
        const size = containerSize * (LAYOUT_CONFIG.VERTEX_SIZE_VW / 100);
        const margin = containerSize * (LAYOUT_CONFIG.VERTEX_MARGIN_VW / 100);
        const fontSize = size * LAYOUT_CONFIG.FONT_SIZE_RATIO;
        const sizePx = `${size}px`, marginPx = `${margin}px`;
        const rightPos = `calc(100% - ${size + margin}px)`;
        const bottomPos = `calc(100% - ${size + margin}px)`;

        vertices.forEach(v => {
            v.style.width = sizePx; v.style.height = sizePx; v.style.fontSize = `${fontSize}px`;
        });
        vertices[0].style.top = marginPx; vertices[0].style.left = marginPx;
        vertices[1].style.top = marginPx; vertices[1].style.left = rightPos;
        vertices[2].style.top = bottomPos; vertices[2].style.left = marginPx;
        vertices[3].style.top = bottomPos; vertices[3].style.left = rightPos;
    }

    function setupNewProblem() {
        if (solvablePuzzles.length === 0) {
            alert("エラー: 問題リストが空です。"); return;
        }
        currentPuzzleIndex = Math.floor(Math.random() * solvablePuzzles.length);
        initialNumbers = [...solvablePuzzles[currentPuzzleIndex]];
        resetProblem();
    }

    function resetProblem() {
        currentNumbers = [...initialNumbers];
        cancelOperation();
        updateDisplay();
    }

    function updateDisplay() {
        vertices.forEach((v, i) => {
            const val = currentNumbers[i];
            if (val !== null) {
                v.textContent = (val instanceof Fraction) ? val.toString() : val;
                v.classList.remove('hidden');
            } else {
                v.textContent = ''; v.classList.add('hidden');
            }
            v.classList.remove('selected', 'selected-subtract', 'selected-divide', 'in-drag-chain');
        });
        if (operationState.sourceIndex !== null) {
            const opVertex = vertices[operationState.sourceIndex];
            switch (operationState.type) {
                case 'multiply': opVertex.classList.add('selected'); break;
                case 'subtract': opVertex.classList.add('selected-subtract'); break;
                case 'divide': opVertex.classList.add('selected-divide'); break;
            }
        }
        if (dragChain.length > 0) {
            dragChain.forEach(index => vertices[index].classList.add('in-drag-chain'));
        }
    }

    // --- 操作・判定ロジック ---
    function selectForOperation(type, index) {
        if (operationState.sourceIndex === index && operationState.type === type) {
            cancelOperation(); return;
        }
        cancelOperation();
        operationState.type = type;
        operationState.sourceIndex = index;
        updateDisplay();
    }
    
    function executeTwoStepOperation(targetIndex) {
        if (operationState.sourceIndex === null || operationState.sourceIndex === targetIndex) {
            cancelOperation(); return;
        }
        let opSymbol;
        switch (operationState.type) {
            case 'multiply': opSymbol = '*'; break;
            case 'subtract': opSymbol = '-'; break;
            case 'divide': opSymbol = '/'; break;
            default: cancelOperation(); return;
        }
        const result = performOperation(opSymbol, currentNumbers[operationState.sourceIndex], currentNumbers[targetIndex]);
        if (result === null) {
            alert("0で割ることはできません。"); cancelOperation(); return;
        }
        currentNumbers[targetIndex] = result;
        currentNumbers[operationState.sourceIndex] = null;
        cancelOperation();
        checkWinCondition();
    }

    function cancelOperation() {
        operationState = { type: null, sourceIndex: null };
        if (isSumDragging) { isSumDragging = false; dragChain = []; }
        updateDisplay();
    }

    function goToNextProblem() { setupNewProblem(); }
    
    function checkWinCondition() {
        updateDisplay();
        const nonNullNumbers = currentNumbers.filter(n => n !== null);
        if (nonNullNumbers.length === 1 && nonNullNumbers[0] === 10) {
            messageArea.textContent = "クリア！ 🎉";
            messageArea.style.display = 'block';
            setTimeout(() => {
                messageArea.style.display = 'none';
                goToNextProblem();
            }, 2000);
        }
    }

    // --- iPhone向けタッチイベントリスナー ---
    function handleTouchStart(e, index) {
        if (currentNumbers[index] === null) return;
        e.preventDefault();

        const pos = e.touches[0];
        interactionState = {
            startX: pos.clientX, startY: pos.clientY,
            startTime: Date.now(), pressTimer: null
        };
        
        // 長押しで減算を選択
        interactionState.pressTimer = setTimeout(() => {
            selectForOperation('subtract', index);
            interactionState.pressTimer = null; // 発火済み
        }, 500);

        // ドラッグ(和)の開始
        isSumDragging = true;
        dragChain = [index];
        updateDisplay();
    }

    function handleTouchMove(e) {
        if (!isSumDragging) return;
        // 指が動いたら長押しはキャンセル
        if (interactionState.pressTimer) clearTimeout(interactionState.pressTimer);

        const pos = e.touches[0];
        const targetElement = document.elementFromPoint(pos.clientX, pos.clientY);
        if (targetElement && targetElement.classList.contains('vertex')) {
            const index = parseInt(targetElement.dataset.index, 10);
            if (currentNumbers[index] !== null && !dragChain.includes(index)) {
                dragChain.push(index);
                updateDisplay();
            }
        }
    }

    function handleTouchEnd(e, index) {
        if (interactionState.pressTimer) clearTimeout(interactionState.pressTimer);

        const touchEndTime = Date.now();
        const pos = e.changedTouches[0];
        const dx = Math.abs(pos.clientX - interactionState.startX);
        const dy = Math.abs(pos.clientY - interactionState.startY);

        // ドラッグ(和)の終了
        if (dragChain.length > 1) {
            let sum = dragChain.reduce((acc, idx) => performOperation('+', acc, currentNumbers[idx]), 0);
            currentNumbers[dragChain[dragChain.length - 1]] = sum;
            dragChain.slice(0, -1).forEach(idx => { currentNumbers[idx] = null; });
            checkWinCondition();
        } 
        // 短いタップ(積)の処理
        else if (touchEndTime - interactionState.startTime < 250 && dx < 10 && dy < 10) {
            if (operationState.sourceIndex !== null && operationState.sourceIndex !== index) {
                executeTwoStepOperation(index);
            } else {
                selectForOperation('multiply', index);
            }
        }
        
        isSumDragging = false;
        dragChain = [];
        if(operationState.type !== 'subtract' && operationState.type !== 'multiply') {
             updateDisplay();
        }
    }

    vertices.forEach((vertex, index) => {
        vertex.addEventListener('touchstart', (e) => handleTouchStart(e, index), { passive: false });
        vertex.addEventListener('touchend', (e) => handleTouchEnd(e, index));
        vertex.addEventListener('dblclick', (e) => { // ダブルタップで除算
            e.preventDefault();
            if (currentNumbers[index] !== null) selectForOperation('divide', index);
        });
    });

    document.addEventListener('touchmove', handleTouchMove, { passive: false });
    
    // --- グローバルリスナー ---
    gameContainer.addEventListener('click', e => { if (e.target === gameContainer) cancelOperation(); });
    resetButton.addEventListener('click', resetProblem);
    nextPuzzleButton.addEventListener('click', goToNextProblem);
    gameContainer.addEventListener('contextmenu', e => e.preventDefault());

    // --- ★ ゲーム開始処理 (CSV読み込み) ---
    async function initializeGame() {
        try {
            // tenp.csvファイルを読み込む
            const response = await fetch('tenp.csv');
            if (!response.ok) throw new Error('CSVファイルの読み込みに失敗しました。');
            
            const csvText = await response.text();
            const puzzleStrings = csvText.trim().replace(/\s/g, '').split(',').filter(s => s.length === 4);
            solvablePuzzles = puzzleStrings.map(str => str.split('').map(digit => parseInt(digit, 10)));
            if (solvablePuzzles.length === 0) throw new Error("有効な問題が見つかりません。");

        } catch (error) {
            console.error(error);
            alert('問題ファイルの読み込みに失敗したため、デフォルトの問題で開始します。');
            solvablePuzzles = [[1, 2, 3, 4], [1, 1, 9, 9], [3, 3, 8, 8]];
        }

        applyLayout();
        setupNewProblem();
    }

    initializeGame();

</script>

</body>
</html>

<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>テンパズル</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Helvetica Neue", "Segoe UI", "Hiragino Kaku Gothic ProN", "Hiragino Sans", "Arial", "Meiryo", sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background-color: #2b2b2b;
            -webkit-user-select: none;
            user-select: none;
        }
        #game-container {
            position: relative;
            width: 95%;
            max-width: 450px;
            aspect-ratio: 1 / 1;
            background-color: #1f1f1f;
            border: 2px solid #333;
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            touch-action: none;
        }
        .vertex {
            position: absolute;
            background-color: #2e2e2e;
            color: white;
            font-weight: bold;

	    border: 2px solid #DBDBDB;
            display: flex;
            justify-content: center;
            align-items: center;
            border-radius: 50%;
            cursor: pointer;
            transition: transform 0.2s, background-color 0.2s, font-family 0.2s;
            box-sizing: border-box;
            padding: 5px;
            line-height: 1.1;
            text-align: center;
        }
        .vertex.hidden { opacity: 0; pointer-events: none; }
        .vertex.selected-multiply { background-color: #d9534f; border: 4px solid #d43f3a; }
        .vertex.selected-divide { background-color: #28a745; border: 4px solid #1e7e34; }
        .vertex.selected-subtract { background-color: #007bff; border: 4px solid #0056b3; }
        .vertex.in-drag-chain { background-color: #5cb85c; border: 4px solid #4cae4c; transform: scale(1.1); }
        
        /* UIコントロールの配置 */
        #font-selector {
            position: absolute;
            top: 10px;
            left: 10px;
            font-size: 14px;
            padding: 5px;
            border-radius: 5px;
            border: 1px solid #ccc;
            z-index: 10;
        }
        #button-container {
            position: absolute;
            top: 10px;
            right: 10px;
            display: flex;
            gap: 8px;
            z-index: 10;
        }
        #reset-button, #next-puzzle-button {
            padding: 8px 12px;
            font-size: 14px;
            cursor: pointer;
            color: white;
            border: none;
            border-radius: 5px;
            flex-shrink: 0;
        }
        #reset-button { background-color: #f0ad4e; }
        #next-puzzle-button { background-color: #337ab7; }
        #message-area {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%); font-size: 48px;
            color: #4CAF50; font-weight: bold; display: none; text-align: center;
        }
        #version-display {
            position: absolute;
            bottom: 10px;
            right: 15px;
            font-size: 14px;
            color: #aaa;
        }
    </style>
</head>
<body>

<div id="game-container">
    <select id="font-selector">
        <option value="Futura, sans-serif">Futura</option>
        <option value="'Century Gothic', sans-serif">Century Gothic</option>
        <option value="Sabon, serif">Sabon</option>
        <option value="'Times New Roman', Times, serif">Times New Roman</option>
    </select>
    
    <div id="button-container">
        <button id="reset-button">リセット</button>
        <button id="next-puzzle-button">次の問題</button>
    </div>
    
    <div id="version-display">Ver. 1.0</div>

    <div id="v0" class="vertex" data-index="0"></div>
    <div id="v1" class="vertex" data-index="1"></div>
    <div id="v2" class="vertex" data-index="2"></div>
    <div id="v3" class="vertex" data-index="3"></div>
    <div id="message-area"></div>
</div>

<script>
    // --- レイアウト設定 ---
    const LAYOUT_CONFIG = {
        VERTEX_SIZE_VW: 20, FONT_SIZE_RATIO: 0.4, VERTEX_MARGIN_VW: 5
    };

    // --- 分数クラス ---
    class Fraction {
        constructor(n, d = 1) { this.n = n; this.d = d; this.simplify(); }
        _gcd(a, b) { return b === 0 ? a : this._gcd(b, a % b); }
        simplify() {
            const c = this._gcd(Math.abs(this.n), Math.abs(this.d));
            this.n /= c; this.d /= c;
            if (this.d < 0) { this.d *= -1; this.n *= -1; }
        }
        toString() { return `${this.n}/${this.d}`; }
        isInteger() { return this.d === 1; }
        static getResult(f) { return f.isInteger() ? f.n : f; }
    }

    // --- 計算ロジック ---
    function performOperation(op, v1, v2) {
        const f1 = (v1 instanceof Fraction) ? v1 : new Fraction(v1);
        const f2 = (v2 instanceof Fraction) ? v2 : new Fraction(v2);
        let r;
        switch (op) {
            case '+': r = new Fraction(f1.n * f2.d + f2.n * f1.d, f1.d * f2.d); break;
            case '-': r = new Fraction(f1.n * f2.d - f2.n * f1.d, f1.d * f2.d); break;
            case '*': r = new Fraction(f1.n * f2.n, f1.d * f2.d); break;
            case '/':
                if (f2.n === 0) return null;
                r = new Fraction(f1.n * f2.d, f1.d * f2.n); break;
        }
        return Fraction.getResult(r);
    }

    // --- ゲームデータと状態変数 ---
    let solvablePuzzles = [];
    let currentPuzzleIndex = 0;
    let initialNumbers = [], currentNumbers = [];
    let operationState = { type: null, sourceIndex: null };
    let isDragging = false;
    let dragChain = [];
    let touchStartInfo = { x: 0, y: 0 };

    // --- DOM要素 ---
    const gameContainer = document.getElementById('game-container');
    const vertices = Array.from(document.querySelectorAll('.vertex'));
    const resetButton = document.getElementById('reset-button');
    const nextPuzzleButton = document.getElementById('next-puzzle-button');
    const messageArea = document.getElementById('message-area');
    const fontSelector = document.getElementById('font-selector');

    // --- 初期化・更新関数 ---
    function applyLayout() {
        const containerSize = gameContainer.offsetWidth;
        const size = containerSize * (LAYOUT_CONFIG.VERTEX_SIZE_VW / 100);
        const margin = containerSize * (LAYOUT_CONFIG.VERTEX_MARGIN_VW / 100);
        const fontSize = size * LAYOUT_CONFIG.FONT_SIZE_RATIO;
        const sizePx = `${size}px`, marginPx = `${margin}px`;
        const rightPos = `calc(100% - ${size + margin}px)`;
        const bottomPos = `calc(100% - ${size + margin}px)`;
        vertices.forEach(v => {
            v.style.width = sizePx; v.style.height = sizePx; v.style.fontSize = `${fontSize}px`;
        });
        vertices[0].style.top = marginPx; vertices[0].style.left = marginPx;
        vertices[1].style.top = marginPx; vertices[1].style.left = rightPos;
        vertices[2].style.top = bottomPos; vertices[2].style.left = marginPx;
        vertices[3].style.top = bottomPos; vertices[3].style.left = rightPos;
    }
    function applyFont() {
        const selectedFont = fontSelector.value;
        vertices.forEach(v => { v.style.fontFamily = selectedFont; });
    }
    function setupNewProblem() {
        if (solvablePuzzles.length === 0) { alert("エラー: 問題リストが空です。"); return; }
        currentPuzzleIndex = Math.floor(Math.random() * solvablePuzzles.length);
        initialNumbers = [...solvablePuzzles[currentPuzzleIndex]];
        resetProblem();
    }
    function resetProblem() {
        currentNumbers = [...initialNumbers];
        cancelOperation();
        updateDisplay();
    }
    function updateDisplay() {
        vertices.forEach((v, i) => {
            const val = currentNumbers[i];
            if (val !== null) {
                v.textContent = (val instanceof Fraction) ? val.toString() : val;
                v.classList.remove('hidden');
            } else {
                v.textContent = ''; v.classList.add('hidden');
            }
            v.classList.remove('selected-multiply', 'selected-divide', 'selected-subtract', 'in-drag-chain');
        });
        if (operationState.sourceIndex !== null) {
            const opVertex = vertices[operationState.sourceIndex];
            if (operationState.type) {
                opVertex.classList.add(`selected-${operationState.type}`);
            }
        }
        if (dragChain.length > 0) {
            dragChain.forEach(index => vertices[index].classList.add('in-drag-chain'));
        }
    }

    // --- 操作・判定ロジック ---
    function selectForOperation(type, index) {
        if (operationState.sourceIndex === index && operationState.type === type) {
            cancelOperation(); return;
        }
        cancelOperation();
        operationState.type = type;
        operationState.sourceIndex = index;
        updateDisplay();
    }
    function executeTwoStepOperation(targetIndex) {
        if (operationState.sourceIndex === null || operationState.sourceIndex === targetIndex) {
            cancelOperation(); return;
        }
        let opSymbol;
        switch (operationState.type) {
            case 'multiply': opSymbol = '*'; break;
            case 'subtract': opSymbol = '-'; break;
            case 'divide': opSymbol = '/'; break;
            default: cancelOperation(); return;
        }
        const result = performOperation(opSymbol, currentNumbers[operationState.sourceIndex], currentNumbers[targetIndex]);
        if (result === null) { alert("0で割ることはできません。"); cancelOperation(); return; }
        currentNumbers[targetIndex] = result;
        currentNumbers[operationState.sourceIndex] = null;
        cancelOperation();
        checkWinCondition();
    }
    function cancelOperation() {
        operationState = { type: null, sourceIndex: null };
        if (isDragging) { isDragging = false; dragChain = []; }
        updateDisplay();
    }
    function goToNextProblem() { setupNewProblem(); }
    function checkWinCondition() {
        updateDisplay();
        const nonNullNumbers = currentNumbers.filter(n => n !== null);
        if (nonNullNumbers.length === 1 && nonNullNumbers[0] === 10) {
            messageArea.textContent = "クリア！ 🎉";
            messageArea.style.display = 'block';
            setTimeout(() => {
                messageArea.style.display = 'none';
                goToNextProblem();
            }, 2000);
        }
    }

    // --- イベント処理 ---
    function handleTap(index) {
        if (currentNumbers[index] === null) return;
        if (operationState.sourceIndex === null) {
            selectForOperation('multiply', index);
            return;
        }
        if (operationState.sourceIndex === index) {
            if (operationState.type === 'multiply') selectForOperation('divide', index);
            else if (operationState.type === 'divide') selectForOperation('subtract', index);
            else cancelOperation();
        } else {
            executeTwoStepOperation(index);
        }
    }
    
    vertices.forEach((vertex, index) => {
        vertex.addEventListener('pointerdown', (e) => {
            if (currentNumbers[index] === null) return;
            e.target.setPointerCapture(e.pointerId);
            isDragging = true;
            dragChain = [index];
            touchStartInfo = { x: e.clientX, y: e.clientY };
        });
    });

    function handleMove(e) {
        if (!isDragging) return;
        e.preventDefault();
        
        const pos = e;
        const targetElement = document.elementFromPoint(pos.clientX, pos.clientY);
        if (targetElement && targetElement.classList.contains('vertex')) {
            const index = parseInt(targetElement.dataset.index, 10);
            if (currentNumbers[index] !== null && !dragChain.includes(index)) {
                dragChain.push(index);
                updateDisplay();
            }
        }
    }
    document.addEventListener('pointermove', handleMove, { passive: false });

    function handleEnd(e) {
        if (!isDragging) return;
        const dx = Math.abs(e.clientX - touchStartInfo.x);
        const dy = Math.abs(e.clientY - touchStartInfo.y);
        
        if (dx < 10 && dy < 10) {
            const targetElement = e.target;
            if(targetElement && targetElement.classList.contains('vertex')) {
                const index = parseInt(targetElement.dataset.index, 10);
                handleTap(index);
            }
        } else {
            if (dragChain.length > 1) {
                const sum = dragChain.reduce((acc, idx) => performOperation('+', acc, currentNumbers[idx]), 0);
                const targetIndex = dragChain[dragChain.length - 1];
                currentNumbers[targetIndex] = sum;
                dragChain.forEach(idx => {
                    if (idx !== targetIndex) currentNumbers[idx] = null;
                });
                checkWinCondition();
            }
        }
        isDragging = false;
        dragChain = [];
        if (dx >= 10 || dy >= 10) {
            updateDisplay();
        }
    }
    document.addEventListener('pointerup', handleEnd);

    // グローバルリスナー
    gameContainer.addEventListener('click', e => { if (e.target === e.currentTarget) cancelOperation(); });
    resetButton.addEventListener('click', resetProblem);
    nextPuzzleButton.addEventListener('click', goToNextProblem);
    fontSelector.addEventListener('change', applyFont);
    gameContainer.addEventListener('contextmenu', e => e.preventDefault());

    // --- ゲーム開始処理 ---
    async function initializeGame() {
        try {
            const response = await fetch('tenp.csv');
            if (!response.ok) throw new Error('CSVファイルの読み込みに失敗しました。');
            const csvText = await response.text();
            const puzzleStrings = csvText.trim().replace(/\s/g, '').split(',').filter(s => s.length === 4);
            solvablePuzzles = puzzleStrings.map(str => str.split('').map(digit => parseInt(digit, 10)));
            if (solvablePuzzles.length === 0) throw new Error("有効な問題が見つかりません。");
        } catch (error) {
            console.error(error);
            alert('問題ファイルの読み込みに失敗したため、デフォルトの問題で開始します。');
            solvablePuzzles = [[1, 2, 3, 4], [1, 1, 9, 9], [3, 3, 8, 8]];
        }
        applyLayout();
        applyFont();
        setupNewProblem();
    }
    initializeGame();
</script>

</body>
</html>

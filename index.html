<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>テンパズル</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Helvetica Neue", "Segoe UI", "Hiragino Kaku Gothic ProN", "Hiragino Sans", "Arial", "Meiryo", sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background-color: #2b2b2b;
            -webkit-user-select: none;
            user-select: none;
        }
        #game-container {
            position: relative;
            width: 95%;
            max-width: 450px;
            aspect-ratio: 11 / 16;
            background-color: #1f1f1f;
            border: 2px solid #333;
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            touch-action: none;
        }
        .vertex {
            position: absolute;
            background-color: #2e2e2e;
            color: white;
            font-weight: bold;
            border: 2px solid #DBDBDB;
            display: flex;
            justify-content: center;
            align-items: center;
            border-radius: 50%;
            cursor: pointer;
            transition: transform 0.2s, background-color 0.2s, font-family 0.2s, color 0.2s, border-color 0.2s;
            box-sizing: border-box;
            padding: 5px;
            line-height: 1.1;
            text-align: center;
        }
        .vertex.hidden { opacity: 0; pointer-events: none; }
        .vertex.selected-multiply { color: #C20000; border-color: #C20000; transform: scale(1.1);}
        .vertex.selected-divide { color: #32B338; border-color: #32B338; transform: scale(1.1);}
        .vertex.selected-subtract { color: #3259E0; border-color: #3259E0; transform: scale(1.1);}
        .vertex.in-drag-chain { color: #E05929; border-color: #E05929;transform: scale(1.1); }
        
        .ui-top-left {
            position: absolute;
            top: 10px;
            left: 10px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            z-index: 10;
        }
        #font-selector {
            font-size: 14px;
            padding: 5px;
            border-radius: 5px;
            border: 1px solid #ccc;
        }
        #puzzle-input-container {
            display: flex;
            gap: 5px;
        }
        #puzzle-input {
            width: 60px;
            padding: 5px;
            font-size: 14px;
            border-radius: 5px;
            border: 1px solid #ccc;
            background-color: #333;
            color: white;
            text-align: center;
        }
        /* ★★★★★ Loadボタンのスタイルを修正 ★★★★★ */
        #load-puzzle-button {
            padding: 5px 10px;
            font-size: 14px;
            cursor: pointer;
            color: white;
            border-radius: 5px;
            background-color: #2D9659;
            border: 3px solid #2D9659;
        }
        
        #button-container {
            position: absolute;
            top: 10px;
            right: 10px;
            display: grid;
            grid-template-columns: repeat(2, auto);
            gap: 8px;
            z-index: 10;
        }
        #reset-button, #next-puzzle-button, #undo-button, #sum-all-button {
            padding: 8px 12px;
            font-size: 14px;
            cursor: pointer;
            background-color: #202020;
            color: white;
            border-radius: 5px;
            flex-shrink: 0;
            width: 80px;
        }
        #reset-button { border: 3px solid #f0ad4e; }
        #undo-button { border: 3px solid #6c757d; }
        #sum-all-button { border: 3px solid #17a2b8; }
        #next-puzzle-button { border: 3px solid #337ab7; }
        #message-area {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%); font-size: 48px;
            color: #4CAF50; font-weight: bold; display: none; text-align: center;
        }
        #version-display {
            position: absolute;
            bottom: 10px;
            right: 15px;
            font-size: 14px;
            color: #aaa;
        }
    </style>
</head>
<body>

<div id="game-container">
    <div class="ui-top-left">
        <select id="font-selector">
            <option value="Sabon, serif">Sabon</option>
            <option value="'Century Gothic', sans-serif">Century Gothic</option>
            <option value="Futura, sans-serif">Futura</option>
            <option value="'Times New Roman', Times, serif">Times New Roman</option>
        </select>
        <div id="puzzle-input-container">
            <input type="number" id="puzzle-input" min="0" max="9999" placeholder="1234">
            <button id="load-puzzle-button">Load</button>
        </div>
    </div>
    
    <div id="button-container">
        <button id="reset-button">Reset</button>
        <button id="next-puzzle-button">Next</button>
        <button id="sum-all-button">Sum all</button>
        <button id="undo-button">Undo</button>
    </div>
    
    <div id="version-display">Ver. 1.2.8</div>

    <div id="v0" class="vertex" data-index="0"></div>
    <div id="v1" class="vertex" data-index="1"></div>
    <div id="v2" class="vertex" data-index="2"></div>
    <div id="v3" class="vertex" data-index="3"></div>
    <div id="message-area"></div>
</div>

<script>
    // --- レイアウト設定 ---
    const LAYOUT_CONFIG = {
        VERTEX_SIZE_VW: 28, FONT_SIZE_RATIO: 0.4,
        SQUARE_SIZE_VW: 40, SQUARE_CENTER_Y_VW: 70, SQUARE_CENTER_X_VW: 50,
    };

    // --- 分数クラス ---
    class Fraction {
        constructor(n, d = 1) { this.n = n; this.d = d; this.simplify(); }
        _gcd(a, b) { return b === 0 ? a : this._gcd(b, a % b); }
        simplify() {
            const c = this._gcd(Math.abs(this.n), Math.abs(this.d));
            this.n /= c; this.d /= c;
            if (this.d < 0) { this.d *= -1; this.n *= -1; }
        }
        toString() { return `${this.n}/${this.d}`; }
        isInteger() { return this.d === 1; }
        static getResult(f) { return f.isInteger() ? f.n : f; }
    }

    // --- 計算ロジック ---
    function performOperation(op, v1, v2) {
        const f1 = (v1 instanceof Fraction) ? v1 : new Fraction(v1);
        const f2 = (v2 instanceof Fraction) ? v2 : new Fraction(v2);
        let r;
        switch (op) {
            case '+': r = new Fraction(f1.n * f2.d + f2.n * f1.d, f1.d * f2.d); break;
            case '-': r = new Fraction(f1.n * f2.d - f2.n * f1.d, f1.d * f2.d); break;
            case '*': r = new Fraction(f1.n * f2.n, f1.d * f2.d); break;
            case '/':
                if (f2.n === 0) return null;
                r = new Fraction(f1.n * f2.d, f1.d * f2.n); break;
        }
        return Fraction.getResult(r);
    }

    // --- ゲームデータと状態変数 ---
    let solvablePuzzles = [];
    let initialNumbers = [], currentNumbers = [];
    let operationState = { type: null, sourceIndex: null };
    let isDragging = false;
    let dragChain = [];
    let touchStartInfo = { x: 0, y: 0 };
    let historyStack = [];

    // --- DOM要素 ---
    const gameContainer = document.getElementById('game-container');
    const vertices = Array.from(document.querySelectorAll('.vertex'));
    const resetButton = document.getElementById('reset-button');
    const nextPuzzleButton = document.getElementById('next-puzzle-button');
    const undoButton = document.getElementById('undo-button');
    const sumAllButton = document.getElementById('sum-all-button');
    const messageArea = document.getElementById('message-area');
    const fontSelector = document.getElementById('font-selector');
    const puzzleInput = document.getElementById('puzzle-input');
    const loadPuzzleButton = document.getElementById('load-puzzle-button');

    // --- 新しい問題を設定する関数 ---
    function setProblem(numbers) {
        historyStack.push(JSON.stringify(currentNumbers));
        initialNumbers = [...numbers];
        currentNumbers = [...numbers];
        historyStack = [];
        cancelOperation();
        updateDisplay();
    }

    // 入力タブから問題を読み込む関数
    function loadProblemFromInput() {
        let value = puzzleInput.value;
        if (value.length > 4) value = value.slice(0, 4);
        puzzleInput.value = value;

        if (value.length === 4 && !isNaN(value)) {
            const newNumbers = value.split('').map(digit => parseInt(digit, 10));
            setProblem(newNumbers);
        } else if (value.length === 4) {
            alert("数字4桁で入力してください。");
        }
    }

    // --- 初期化・更新関数 ---
    function applyLayout() {
        const containerSize = gameContainer.offsetWidth;
        const vertexSize = containerSize * (LAYOUT_CONFIG.VERTEX_SIZE_VW / 100);
        const fontSize = vertexSize * LAYOUT_CONFIG.FONT_SIZE_RATIO;
        vertices.forEach(v => {
            v.style.width = `${vertexSize}px`;
            v.style.height = `${vertexSize}px`;
            v.style.fontSize = `${fontSize}px`;
        });
        const centerX = containerSize * (LAYOUT_CONFIG.SQUARE_CENTER_X_VW / 100);
        const centerY = containerSize * (LAYOUT_CONFIG.SQUARE_CENTER_Y_VW / 100);
        const halfSquareSize = containerSize * (LAYOUT_CONFIG.SQUARE_SIZE_VW / 100) / 2;
        const topLeft = { x: centerX - halfSquareSize, y: centerY - halfSquareSize };
        const topRight = { x: centerX + halfSquareSize, y: centerY - halfSquareSize };
        const bottomLeft = { x: centerX - halfSquareSize, y: centerY + halfSquareSize };
        const bottomRight = { x: centerX + halfSquareSize, y: centerY + halfSquareSize };
        const halfVertexSize = vertexSize / 2;
        vertices[0].style.left = `${topLeft.x - halfVertexSize}px`;
        vertices[0].style.top = `${topLeft.y - halfVertexSize}px`;
        vertices[1].style.left = `${topRight.x - halfVertexSize}px`;
        vertices[1].style.top = `${topRight.y - halfVertexSize}px`;
        vertices[2].style.left = `${bottomLeft.x - halfVertexSize}px`;
        vertices[2].style.top = `${bottomLeft.y - halfVertexSize}px`;
        vertices[3].style.left = `${bottomRight.x - halfVertexSize}px`;
        vertices[3].style.top = `${bottomRight.y - halfVertexSize}px`;
    }
    function applyFont() {
        const selectedFont = fontSelector.value;
        vertices.forEach(v => { v.style.fontFamily = selectedFont; });
    }
    function setupNewProblem() {
        if (solvablePuzzles.length === 0) { alert("エラー: 問題リストが空です。"); return; }
        const randomIndex = Math.floor(Math.random() * solvablePuzzles.length);
        const newNumbers = solvablePuzzles[randomIndex];
        setProblem(newNumbers);
    }
    function resetProblem() {
        currentNumbers = [...initialNumbers];
        historyStack = [];
        cancelOperation();
        updateDisplay();
    }
    function updateDisplay() {
        vertices.forEach((v, i) => {
            const val = currentNumbers[i];
            if (val !== null) {
                v.textContent = (val instanceof Fraction) ? val.toString() : val;
                v.classList.remove('hidden');
            } else {
                v.textContent = ''; v.classList.add('hidden');
            }
            v.classList.remove('selected-multiply', 'selected-divide', 'selected-subtract', 'in-drag-chain');
        });
        if (operationState.sourceIndex !== null) {
            const opVertex = vertices[operationState.sourceIndex];
            if (operationState.type) {
                opVertex.classList.add(`selected-${operationState.type}`);
            }
        }
        if (dragChain.length > 0) {
            dragChain.forEach(index => vertices[index].classList.add('in-drag-chain'));
        }
    }
    function fractionReviver(key, value) {
        if (typeof value === 'object' && value !== null && 'n' in value && 'd' in value) {
            return new Fraction(value.n, value.d);
        }
        return value;
    }
    function undoMove() {
        if (historyStack.length > 0) {
            const lastStateJSON = historyStack.pop();
            currentNumbers = JSON.parse(lastStateJSON, fractionReviver);
            cancelOperation();
            updateDisplay();
        }
    }
    function sumAll() {
        const nonNullNumbers = currentNumbers.filter(n => n !== null);
        if (nonNullNumbers.length <= 1) return;
        historyStack.push(JSON.stringify(currentNumbers));
        const totalSum = nonNullNumbers.reduce((acc, num) => performOperation('+', acc, num), 0);
        const targetIndex = currentNumbers.findIndex(n => n !== null);
        const newNumbers = [null, null, null, null];
        newNumbers[targetIndex] = totalSum;
        currentNumbers = newNumbers;
        cancelOperation();
        checkWinCondition();
    }

    // --- 操作・判定ロジック ---
    function selectForOperation(type, index) {
        if (operationState.sourceIndex === index && operationState.type === type) {
            cancelOperation(); return;
        }
        cancelOperation();
        operationState.type = type;
        operationState.sourceIndex = index;
        updateDisplay();
    }
    function executeTwoStepOperation(targetIndex) {
        if (operationState.sourceIndex === null || operationState.sourceIndex === targetIndex) {
            cancelOperation(); return;
        }
        historyStack.push(JSON.stringify(currentNumbers));
        let opSymbol;
        switch (operationState.type) {
            case 'multiply': opSymbol = '*'; break;
            case 'subtract': opSymbol = '-'; break;
            case 'divide': opSymbol = '/'; break;
            default: cancelOperation(); return;
        }
        const result = performOperation(opSymbol, currentNumbers[operationState.sourceIndex], currentNumbers[targetIndex]);
        if (result === null) { alert("0で割ることはできません。"); cancelOperation(); return; }
        currentNumbers[targetIndex] = result;
        currentNumbers[operationState.sourceIndex] = null;
        cancelOperation();
        checkWinCondition();
    }
    function cancelOperation() {
        operationState = { type: null, sourceIndex: null };
        if (isDragging) { isDragging = false; dragChain = []; }
        updateDisplay();
    }
    function goToNextProblem() { setupNewProblem(); }
    function checkWinCondition() {
        updateDisplay();
        const hasTen = currentNumbers.includes(10);
        const allOthersAreValid = currentNumbers.every(n => 
            n === 10 || n === 1 || n === 0 || n === null
        );
        if (hasTen && allOthersAreValid) {
            messageArea.textContent = "Clear！";
            messageArea.style.display = 'block';
            setTimeout(() => {
                messageArea.style.display = 'none';
                goToNextProblem();
            }, 2000);
        }
    }

    // --- イベント処理 ---
    vertices.forEach((vertex, index) => {
        vertex.addEventListener('pointerdown', (e) => {
            if (currentNumbers[index] === null) return;
            if (e.target.closest('#font-selector, #button-container, #puzzle-input-container')) return;
            e.target.setPointerCapture(e.pointerId);
            isDragging = true;
            dragChain = [index];
            touchStartInfo = { x: e.clientX, y: e.clientY };
        });
    });
    function handleMove(e) {
        if (!isDragging) return;
        e.preventDefault();
        const pos = e;
        const targetElement = document.elementFromPoint(pos.clientX, pos.clientY);
        if (targetElement && targetElement.classList.contains('vertex')) {
            const index = parseInt(targetElement.dataset.index, 10);
            if (currentNumbers[index] !== null && !dragChain.includes(index)) {
                dragChain.push(index);
                updateDisplay();
            }
        }
    }
    document.addEventListener('pointermove', handleMove, { passive: false });

    const SWIPE_THRESHOLD_MIN = 50;
    const SWIPE_THRESHOLD_MAX = 300;

    function handleEnd(e) {
        if (!isDragging) return;
        
        const dx = e.clientX - touchStartInfo.x;
        const dy = e.clientY - touchStartInfo.y;
        const distance = Math.sqrt(dx * dx + dy * dy);

        let index = -1;
        const startElement = document.elementFromPoint(touchStartInfo.x, touchStartInfo.y);
        if (startElement && startElement.classList.contains('vertex')) {
            index = parseInt(startElement.dataset.index, 10);
        }
        if (index === -1) {
             isDragging = false; dragChain = []; updateDisplay(); return;
        }

        if (dragChain.length > 1) {
            historyStack.push(JSON.stringify(currentNumbers));
            const sum = dragChain.reduce((acc, idx) => performOperation('+', acc, currentNumbers[idx]), 0);
            const targetIndex = dragChain[dragChain.length - 1];
            currentNumbers[targetIndex] = sum;
            dragChain.forEach(idx => {
                if (idx !== targetIndex) currentNumbers[idx] = null;
            });
            checkWinCondition();
        }
        else if (distance >= SWIPE_THRESHOLD_MIN && distance <= SWIPE_THRESHOLD_MAX) {
            selectForOperation('subtract', index);
        }
        else if (distance < SWIPE_THRESHOLD_MIN) {
            if (operationState.sourceIndex === null) {
                selectForOperation('multiply', index);
            } else {
                if (operationState.sourceIndex === index) {
                    selectForOperation('divide', index);
                } else {
                    executeTwoStepOperation(index);
                }
            }
        }
        
        isDragging = false;
        dragChain = [];
        updateDisplay();
    }
    document.addEventListener('pointerup', handleEnd);

    // グローバルリスナー
    gameContainer.addEventListener('click', e => { if (e.target === e.currentTarget) cancelOperation(); });
    resetButton.addEventListener('click', resetProblem);
    nextPuzzleButton.addEventListener('click', goToNextProblem);
    undoButton.addEventListener('click', undoMove);
    sumAllButton.addEventListener('click', sumAll);
    fontSelector.addEventListener('change', applyFont);
    loadPuzzleButton.addEventListener('click', loadProblemFromInput);
    puzzleInput.addEventListener('input', () => {
        if (puzzleInput.value.length > 4) {
            puzzleInput.value = puzzleInput.value.slice(0, 4);
        }
    });
    gameContainer.addEventListener('contextmenu', e => e.preventDefault());

    // --- ゲーム開始処理 ---
    async function initializeGame() {
        try {
            const response = await fetch('tenp.csv');
            if (!response.ok) throw new Error('CSVファイルの読み込みに失敗しました。');
            const csvText = await response.text();
            const puzzleStrings = csvText.trim().replace(/\s/g, '').split(',').filter(s => s.length === 4);
            solvablePuzzles = puzzleStrings.map(str => str.split('').map(digit => parseInt(digit, 10)));
            if (solvablePuzzles.length === 0) throw new Error("有効な問題が見つかりません。");
        } catch (error) {
            console.error(error);
            alert('問題ファイルの読み込みに失敗したため、デフォルトの問題で開始します。');
            solvablePuzzles = [[1, 2, 3, 4], [1, 9, 9, 9], [3, 3, 8, 8]];
        }
        applyLayout();
        applyFont();
        setupNewProblem();
    }
    initializeGame();
</script>

</body>
</html>
